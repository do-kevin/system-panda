import { Database, Collections, Collection, Field } from "../util/index.js";

const makePrismaModel = async (db: Database, collections: Collections) => {
	const dataSource = `// Generated by SystemPanda, do NOT modify,\n// configure your SystemPanda collections object instead.\n\ndatasource db {\n\tprovider = "${
		db.URI?.split(":")[0]
	}"\n\turl = env("DATABASE_URL")\n}\n\ngenerator client {\n\tprovider = "prisma-client-js"\n}\n\n`;

	// for checking one-to-one relations
	const relationMap: Record<string, boolean> = {};

	return (
		dataSource +
		Object.keys(collections)
			.map(collection => {
				const { fields, id } = collections[collection];
				const idType = !id?.type || id?.type === "autoincrement" ? "Int" : "String";
				const idDefault = id?.type ? `${id.type}()` : "autoincrement()";
				const idName = id?.name || "id";

				const model = [
					`model ${collection} {`,
					`\t${idName} ${idType} @id @default(${idDefault})`,
				];

				for (const field in fields) {
					const key = fields[field];
					const { type } = key;
					const formattedField = field.replace(/\s/g, "_");
					const parts = ["\t" + formattedField];
					let fieldType;

					if (type === "number") fieldType = key.kind;
					else fieldType = type;

					if (type === "relation") {
						const { ref, many } = key;
						const reference =
							ref.indexOf(".") === -1 ? ref : ref.slice(0, ref.indexOf("."));

						parts.push(reference + (many ? "[]" : "?"));

						/*
							one-to-one relations
							1. set related collection name
							2. if current relation not in map, push @relation attribute
							because both shouldn't have it
						*/
						if (!many) {
							if (!relationMap[reference]) relationMap[reference] = true;

							if (!relationMap[collection])
								parts.push(
									`@relation(fields: [${formattedField}Id], references: [id])`
								);
						}

						parts.push(`\n\t${formattedField}Id ${idType}? @unique`);
					} else {
						const { required, unique, map, defaultValue } = key;
						parts.push(`${required ? fieldType : `${fieldType}?`}`);

						if (unique) parts.push("@unique");
						if (map) parts.push(`@map("${map}")`);
						if (defaultValue) {
							let value;

							if (type === "DateTime" && typeof defaultValue === "object") {
								value = defaultValue.kind + "()";
							} else {
								value = JSON.stringify(defaultValue);
							}

							parts.push(`@default(${value})`);
						}
					}

					model.push(parts.join(" "));
				}

				// @index
				for (const field in fields) {
					const val = fields[field];

					if (val.type !== "relation" && val.index) {
						model.push(`\t@@index([${field}])`);
					}
				}

				model.push("}");
				return model.join("\n") + "\n";
			})
			.join("\n")
	);
};

export { makePrismaModel };
