import { Database, Collections } from "../util/index.js";

const makePrismaModel = async (db: Database, collections: Collections) => {
	const dataSource = `// Generated by SystemPanda, do NOT modify,\n// configure your SystemPanda collections object instead.\n\ndatasource db {\n\tprovider = "${
		db.URI?.split(":")[0]
	}"\n\turl = env("DATABASE_URL")\n}\n\ngenerator client {\n\tprovider = "prisma-client-js"\n}\n\n`;

	// for checking one-to-many relations
	const relationMap: Record<string, boolean> = {};

	return (
		dataSource +
		Object.keys(collections)
			.map(collection => {
				const { fields, id } = collections[collection];
				const idType = !id?.type || id?.type === "autoincrement" ? "Int" : "String";
				const idDefault = id?.type ? `${id.type}()` : "autoincrement()";
				const idName = id?.name || "id";

				const model = [
					`model ${collection} {`,
					`\t${idName} ${idType} @id @default(${idDefault})`,
				];

				for (const field in fields) {
					const key = fields[field];
					const { type } = key;
					const formattedField = field.replace(/\s/g, "_");
					const parts = ["\t" + formattedField];
					const fieldType = type === "number" ? key.subtype : type;

					if (type === "relation") {
						const { ref, many } = key;
						const reference =
							ref.indexOf(".") === -1 ? ref : ref.slice(0, ref.indexOf("."));

						parts.push(reference + (many ? "[]" : "?"));

						if (!many) {
							if (!relationMap[reference]) relationMap[reference] = true;
							const isOneToManyRelation = !relationMap[collection];

							if (isOneToManyRelation) {
								parts.push(
									`@relation(fields: [${formattedField}Id], references: [id])`
								);
							}
						}

						parts.push(`\n\t${formattedField}Id ${idType}? @map("${formattedField}")`);

						let refSameName = false;

						if (ref.indexOf(".") === -1) refSameName = true;

						const referencedColRel =
							collections[refSameName ? ref : ref.slice(0, ref.indexOf("."))].fields[
								refSameName ? ref : ref.slice(ref.indexOf(".") + 1)
							];

						const isOneToOneRelation =
							(referencedColRel?.type === "relation" &&
								!referencedColRel.many &&
								!many) ||
							!referencedColRel;

						if (isOneToOneRelation) {
							parts.push("@unique");
						}
					} else {
						const { required, unique, map, defaultValue } = key;
						parts.push(`${required ? fieldType : `${fieldType}?`}`);

						if (unique) parts.push("@unique");
						if (map) parts.push(`@map("${map}")`);
						if (defaultValue) {
							let value;

							if (type === "DateTime" && typeof defaultValue === "object") {
								value = defaultValue.kind + "()";
							} else {
								value = JSON.stringify(defaultValue);
							}

							parts.push(`@default(${value})`);
						}
					}

					model.push(parts.join(" "));
				}

				// @index
				for (const field in fields) {
					const val = fields[field];

					if (val.type !== "relation" && val.index) {
						model.push(`\t@@index([${field}])`);
					}
				}

				model.push("}");
				return model.join("\n") + "\n";
			})
			.join("\n")
	);
};

export { makePrismaModel };
