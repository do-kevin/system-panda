import { Database, Collections, RelationField } from "../util/index.js";

const makePrismaModel = (db: Database, collections: Collections) => {
	const dataSource = `// Generated by SystemPanda, do NOT modify,\n// configure your SystemPanda collections object instead.\n\ndatasource db {\n\tprovider = "${
		db.URI?.split(":")[0]
	}"\n\turl = env("DATABASE_URL")\n}\n\ngenerator client {\n\tprovider = "prisma-client-js"\n}\n\n`;

	/*
		toggling collection names for one-to-one relations,
		so that the @relation attribute is only applied to one of them
	*/
	const toggleMap: Record<string, boolean> = {};

	return (
		dataSource +
		Object.keys(collections)
			.map(collection => {
				const { fields, id } = collections[collection];
				const idType = !id?.type || id?.type === "autoincrement" ? "Int" : "String";
				const idDefault = id?.type ? `${id.type}()` : "autoincrement()";
				const idName = id?.name || "id";

				const model = [
					`model ${collection} {`,
					`\t${idName} ${idType} @id @default(${idDefault})`,
				];

				for (const field in fields) {
					const key = fields[field];
					const { type } = key;
					const formattedField = field.replace(/\s/g, "_");
					const parts = ["\t" + formattedField];
					const fieldType = type === "number" ? key.subtype : type;

					if (type === "relation") {
						/* relation field */

						const { ref, many } = key;
						const baseRef =
							ref.indexOf(".") === -1 ? ref : ref.slice(0, ref.indexOf("."));

						const relatedCollection: { [key: string]: [string, RelationField] } =
							Object.entries(collections[baseRef].fields).reduce<{
								[key: string]: [string, RelationField];
							}>((result, [k, v]) => {
								if (v.type === "relation") {
									result[collection] = [k, v];
								}
								return result;
							}, {});

						const [_, refRelationValue] = relatedCollection[collection];
						let relationKind;

						if (many && refRelationValue.many) relationKind = "manyToMany";
						else if (
							(many && !refRelationValue.many) ||
							(!many && refRelationValue.many)
						)
							relationKind = "oneToMany";
						else if (!many && !refRelationValue.many) relationKind = "oneToOne";

						parts.push(baseRef + (many ? "[]" : "?"));

						if (!many) {
							if (!toggleMap[baseRef]) toggleMap[baseRef] = true;
							const isToggled = toggleMap[collection];

							if (
								(relationKind === "oneToMany" || relationKind === "oneToOne") &&
								!isToggled
							) {
								parts.push(
									`@relation(fields: [${formattedField}Id], references: [id])`
								);
							}

							parts.push(
								`\n\t${formattedField}Id ${
									!collections[baseRef].id?.type ||
									collections[baseRef].id?.type === "autoincrement"
										? "Int"
										: "String"
								}? @map("${formattedField}")`
							);

							if (relationKind === "oneToOne") {
								parts.push("@unique");
							}
						}
					} else {
						/* other types of fields */

						const { required, unique, map, defaultValue } = key;
						parts.push(`${required ? fieldType : `${fieldType}?`}`);

						if (unique) parts.push("@unique");
						if (map) parts.push(`@map("${map}")`);
						if (defaultValue) {
							let value;

							if (type === "DateTime" && typeof defaultValue === "object") {
								if (defaultValue.kind === "now") {
									value = defaultValue.kind + "()";
								} else if (defaultValue.kind === "updatedAt") {
									value = "@" + defaultValue.kind;
								}
							} else {
								value = JSON.stringify(defaultValue);
							}

							if (value?.startsWith("@")) parts.push(value);
							else parts.push(`@default(${value})`);
						}
					}

					model.push(parts.join(" "));
				}

				// @index attribute
				for (const field in fields) {
					const val = fields[field];

					if (val.type !== "relation" && val.index) {
						model.push(`\t@@index([${field}])`);
					}
				}

				model.push("}");
				return model.join("\n") + "\n";
			})
			.join("\n")
	);
};

export { makePrismaModel };
