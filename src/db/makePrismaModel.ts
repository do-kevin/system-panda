import { toPascalCase, Database, Collections } from "../util/index.js";

const makePrismaModel = async (db: Database, collections: Collections) => {
	const dataSource = `// Generated by SystemPanda, do NOT modify,\n// configure your SystemPanda collections object instead.\n\ndatasource db {\n\tprovider = "${
		db.URI?.split(":")[0]
	}"\n\turl = env("DATABASE_URL")\n}\n\ngenerator client {\n\tprovider = "prisma-client-js"\n}\n\n`;

	return (
		dataSource +
		Object.keys(collections)
			.map(collection => {
				const { fields, id } = collections[collection];
				const idType = !id?.type || id?.type === "autoincrement" ? "Int" : "String";
				const idDefault = id?.type ? `${id.type}()` : "autoincrement()";
				const idName = id?.name || "id";

				const lines = [
					`model ${toPascalCase(collection)} {`,
					`\t${idName} ${idType} @id @default(${idDefault})`,
				];

				for (const field in fields) {
					const { defaultValue, required, type, unique, map } = fields[field];

					const requiredTypeOrNot = required ? type : `${type}?`;
					const parts = ["\t" + field.replace(/\s/g, "_"), requiredTypeOrNot];

					if (unique) parts.push("@unique");
					if (map) parts.push(`@map("${map}")`);
					if (defaultValue)
						parts.push(
							`@default(${
								type === "DateTime" ? "now()" : JSON.stringify(defaultValue)
							})`
						);

					lines.push(parts.join(" "));
				}

				for (const field in fields) {
					const { index } = fields[field];
					const parts = [];

					if (index) {
						parts.push(`\t@@index([${field}])`);
						lines.push(parts.join(""));
					}
				}

				lines.push("}");

				return lines.join("\n") + "\n";
			})
			.join("\n")
	);
};

export { makePrismaModel };
